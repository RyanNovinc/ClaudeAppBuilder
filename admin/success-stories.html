<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Admin: Success Stories - AppFoundry</title>

    <!-- Add Tailwind CSS via CDN -->
    <script src="https://cdn.tailwindcss.com"></script>
    
    <!-- Font Awesome for icons -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css" />
    
    <!-- Supabase JS Client -->
    <script src="https://unpkg.com/@supabase/supabase-js@2"></script>
    
    <!-- Admin Auth Helper Script with Supabase Integration -->
    <script>
    /**
     * Admin Authentication Helper with Supabase Integration
     * This file provides a consistent interface for authenticating with the Netlify Functions API
     * and includes Supabase integration for direct database operations
     */

    const AdminAuth = {
      // The token from your admin page - replace this with your actual token
      token: "xP8q#Rb7!DtEv3mK9$Lz",
      
      // Supabase configuration - using correct values
      supabaseUrl: 'https://vyzsauyekanaxevgxkyh.supabase.co',
      supabaseAnonKey: 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InZ5enNhdXlla2FuYXhldmd4a3loIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NDYzMjgzOTIsImV4cCI6MjA2MTkwNDM5Mn0.VPs_JhAkoCUediOP4_0flNF9AURcQDH-Hfj8T0vi5_c',
      supabaseClient: null,
      
      // Initialize Supabase client
      initSupabase() {
        if (!this.supabaseClient && typeof supabase !== 'undefined') {
          try {
            this.supabaseClient = supabase.createClient(this.supabaseUrl, this.supabaseAnonKey);
            console.log("🔄 Supabase client initialized");
            return this.supabaseClient;
          } catch (e) {
            console.error("❌ Error initializing Supabase client:", e);
            return null;
          }
        }
        return this.supabaseClient;
      },
      
      // Call any API endpoint with proper authentication
      async callApi(endpoint, method = 'GET', body = null) {
        try {
          const options = {
            method: method,
            headers: {
              'Authorization': `Bearer ${this.token}`,
              'Content-Type': 'application/json'
            }
          };
          
          if (body) {
            options.body = JSON.stringify(body);
          }
          
          console.log(`📡 Calling API: ${endpoint} (${method})`);
          const response = await fetch(`/.netlify/functions/${endpoint}`, options);
          
          if (!response.ok) {
            const errorText = await response.text();
            console.error(`❌ API error (${response.status}):`, errorText);
            throw new Error(`API error (${response.status}): ${errorText}`);
          }
          
          console.log(`✅ API call successful: ${endpoint}`);
          return await response.json();
        } catch (error) {
          console.error(`❌ API call to ${endpoint} failed:`, error);
          
          // Track failed API calls for monitoring
          this.recordApiFailure(endpoint, method, error);
          
          throw error;
        }
      },
      
      // Get submissions with status filter
      async getSubmissions(status = 'all') {
        try {
          // Try to use API first
          return await this.callApi(`get-submissions?status=${status}`);
        } catch (error) {
          logActivity('warning', `API call to get submissions failed: ${error.message}. Trying direct Supabase connection.`);
          
          // Fallback to direct Supabase connection if API fails
          return this.getSubmissionsFromSupabase(status);
        }
      },
      
      // Get submissions directly from Supabase
      async getSubmissionsFromSupabase(status = 'all') {
        try {
          // Initialize Supabase client if needed
          const supabase = this.initSupabase();
          if (!supabase) {
            throw new Error("Supabase client not available");
          }
          
          // Build query
          let query = supabase.from('submissions').select('*');
          
          if (status !== 'all') {
            query = query.eq('status', status);
          }
          
          // Execute query
          const { data, error } = await query.order('created_at', { ascending: false });
          
          if (error) throw error;
          
          // Format submissions to match expected structure
          return data.map(submission => {
            // Parse cloudinary_images
            let images = [];
            try {
              if (submission.cloudinary_images) {
                if (typeof submission.cloudinary_images === 'string') {
                  images = JSON.parse(submission.cloudinary_images);
                } else if (Array.isArray(submission.cloudinary_images)) {
                  images = submission.cloudinary_images;
                }
              }
            } catch (e) {
              console.error(`Error parsing cloudinary_images for submission ${submission.id}:`, e);
            }
            
            return {
              id: submission.id,
              name: submission.name,
              email: submission.email,
              appName: submission.app_name,
              appType: submission.app_type,
              experienceLevel: submission.experience_level,
              testimonial: submission.testimonial,
              story: submission.story,
              status: submission.status,
              date: submission.created_at,
              images: images,
              featured: submission.featured || false
            };
          });
        } catch (error) {
          logActivity('error', `Error getting submissions from Supabase: ${error.message}`);
          
          // Fall back to localStorage as a last resort
          return this.getSubmissionsFromLocalStorage(status);
        }
      },
      
      // Get submissions from localStorage as last fallback
      getSubmissionsFromLocalStorage(status = 'all') {
        try {
          logActivity('warning', "Falling back to localStorage for submissions");
          
          const storedSubmissions = localStorage.getItem('appfoundry_submissions');
          
          if (!storedSubmissions) {
            return [];
          }
          
          let submissions = JSON.parse(storedSubmissions);
          
          if (status !== 'all') {
            submissions = submissions.filter(sub => sub.status === status);
          }
          
          return submissions;
        } catch (error) {
          logActivity('error', `Error getting submissions from localStorage: ${error.message}`);
          return [];
        }
      },
      
      // Approve a submission
      async approveSubmission(id) {
        try {
          logActivity('info', `Approving submission ${id}`);
          
          // Try API first
          try {
            const result = await this.callApi('approve-submission', 'POST', { id });
            
            // Update localStorage as fallback
            this.updateLocalStorage(id, 'approved');
            
            return result;
          } catch (apiError) {
            logActivity('warning', `API call to approve submission failed: ${apiError.message}. Trying direct Supabase connection.`);
            
            // Fallback to direct Supabase connection
            return this.approveSubmissionInSupabase(id);
          }
        } catch (error) {
          logActivity('error', `Error approving submission: ${error.message}`);
          throw error;
        }
      },
      
      // Approve submission directly in Supabase
      async approveSubmissionInSupabase(id) {
        try {
          // Initialize Supabase client if needed
          const supabase = this.initSupabase();
          if (!supabase) {
            throw new Error("Supabase client not available");
          }
          
          // Update the submission
          const { data, error } = await supabase
            .from('submissions')
            .update({ status: 'approved' })
            .eq('id', id)
            .select()
            .single();
            
          if (error) throw error;
          
          // Update localStorage
          this.updateLocalStorage(id, 'approved');
          
          // Format the result to match the API response
          const formattedSubmission = {
            id: data.id,
            name: data.name,
            email: data.email,
            appName: data.app_name,
            appType: data.app_type,
            experienceLevel: data.experience_level,
            testimonial: data.testimonial,
            story: data.story,
            status: data.status,
            date: data.created_at,
            images: this.parseCloudinaryImages(data.cloudinary_images),
            featured: data.featured || false
          };
          
          logActivity('success', `Successfully approved submission ${id} in Supabase`);
          
          return {
            success: true,
            message: "Submission approved successfully",
            submission: formattedSubmission
          };
        } catch (error) {
          logActivity('error', `Error approving submission in Supabase: ${error.message}`);
          
          // Fall back to localStorage as a last resort
          const success = this.updateLocalStorage(id, 'approved');
          
          if (success) {
            logActivity('info', `Approved submission ${id} in localStorage only`);
            
            return {
              success: true,
              message: "Submission approved in localStorage only",
              offline: true
            };
          }
          
          throw error;
        }
      },
      
      // Reject a submission
      async rejectSubmission(id) {
        try {
          logActivity('info', `Rejecting submission ${id}`);
          
          // Try API first
          try {
            const result = await this.callApi('reject-submission', 'POST', { id });
            
            // Update localStorage as fallback
            this.updateLocalStorage(id, 'rejected');
            
            return result;
          } catch (apiError) {
            logActivity('warning', `API call to reject submission failed: ${apiError.message}. Trying direct Supabase connection.`);
            
            // Fallback to direct Supabase connection
            return this.rejectSubmissionInSupabase(id);
          }
        } catch (error) {
          logActivity('error', `Error rejecting submission: ${error.message}`);
          throw error;
        }
      },
      
      // Reject submission directly in Supabase
      async rejectSubmissionInSupabase(id) {
        try {
          // Initialize Supabase client if needed
          const supabase = this.initSupabase();
          if (!supabase) {
            throw new Error("Supabase client not available");
          }
          
          // Update the submission
          const { data, error } = await supabase
            .from('submissions')
            .update({ status: 'rejected' })
            .eq('id', id)
            .select()
            .single();
            
          if (error) throw error;
          
          // Update localStorage
          this.updateLocalStorage(id, 'rejected');
          
          // Format the result to match the API response
          const formattedSubmission = {
            id: data.id,
            name: data.name,
            email: data.email,
            appName: data.app_name,
            appType: data.app_type,
            experienceLevel: data.experience_level,
            testimonial: data.testimonial,
            story: data.story,
            status: data.status,
            date: data.created_at,
            images: this.parseCloudinaryImages(data.cloudinary_images),
            featured: data.featured || false
          };
          
          logActivity('success', `Successfully rejected submission ${id} in Supabase`);
          
          return {
            success: true,
            message: "Submission rejected successfully",
            submission: formattedSubmission
          };
        } catch (error) {
          logActivity('error', `Error rejecting submission in Supabase: ${error.message}`);
          
          // Fall back to localStorage as a last resort
          const success = this.updateLocalStorage(id, 'rejected');
          
          if (success) {
            logActivity('info', `Rejected submission ${id} in localStorage only`);
            
            return {
              success: true,
              message: "Submission rejected in localStorage only",
              offline: true
            };
          }
          
          throw error;
        }
      },
      
      // Set a story as featured
      async setFeaturedStory(id) {
        try {
          logActivity('info', `Setting submission ${id} as featured`);
          
          // Try direct Supabase first
          const supabase = this.initSupabase();
          if (!supabase) {
            throw new Error("Supabase client not available");
          }
          
          // First, unmark any currently featured stories
          const { error: clearError } = await supabase
            .from('submissions')
            .update({ featured: false })
            .eq('featured', true);
            
          if (clearError) throw clearError;
          
          // Now mark the selected story as featured
          const { data, error } = await supabase
            .from('submissions')
            .update({ featured: true })
            .eq('id', id)
            .select()
            .single();
            
          if (error) throw error;
          
          // Update localStorage
          this.updateFeaturedInLocalStorage(id);
          
          logActivity('success', `Successfully set submission ${id} as featured in Supabase`);
          
          // Format the result
          const formattedSubmission = {
            id: data.id,
            name: data.name,
            email: data.email,
            appName: data.app_name,
            appType: data.app_type,
            experienceLevel: data.experience_level,
            testimonial: data.testimonial,
            story: data.story,
            status: data.status,
            date: data.created_at,
            images: this.parseCloudinaryImages(data.cloudinary_images),
            featured: data.featured || false
          };
          
          return {
            success: true,
            message: "Submission set as featured successfully",
            submission: formattedSubmission
          };
        } catch (error) {
          logActivity('error', `Error setting featured story: ${error.message}`);
          
          // Try to update localStorage at least
          const success = this.updateFeaturedInLocalStorage(id);
          
          if (success) {
            logActivity('info', `Set submission ${id} as featured in localStorage only`);
            
            return {
              success: true,
              message: "Submission set as featured in localStorage only",
              offline: true
            };
          }
          
          throw error;
        }
      },
      
      // Update featured flag in localStorage
      updateFeaturedInLocalStorage(id) {
        try {
          // Find the submission
          const submissions = JSON.parse(localStorage.getItem('appfoundry_submissions') || '[]');
          
          // First, unmark any currently featured submissions
          submissions.forEach(sub => {
            if (sub.featured) {
              sub.featured = false;
            }
          });
          
          // Mark the selected submission as featured
          const submissionIndex = submissions.findIndex(s => s.id === id);
          
          if (submissionIndex !== -1) {
            submissions[submissionIndex].featured = true;
            
            // Save to localStorage
            localStorage.setItem('appfoundry_submissions', JSON.stringify(submissions));
            
            // Also store the featured story ID separately for easier access
            localStorage.setItem('appfoundry_featured_story', id);
            
            // Update seed immediately too
            localStorage.setItem('appfoundry_approved_seed', JSON.stringify(
              submissions.filter(s => s.status === 'approved')
            ));
            
            logActivity('info', `Set submission ${id} as featured in localStorage`);
            return true;
          }
          
          logActivity('warning', `Could not find submission ${id} in localStorage to set as featured`);
          return false;
        } catch (error) {
          logActivity('error', `Error updating featured status in localStorage: ${error.message}`);
          return false;
        }
      },
      
      // Parse Cloudinary images
      parseCloudinaryImages(cloudinaryImages) {
        if (!cloudinaryImages) return [];
        
        try {
          if (typeof cloudinaryImages === 'string') {
            return JSON.parse(cloudinaryImages);
          }
          
          if (Array.isArray(cloudinaryImages)) {
            return cloudinaryImages;
          }
        } catch (error) {
          console.error('Error parsing Cloudinary images:', error);
        }
        
        return [];
      },
      
      // Clear all rejected submissions
      async clearRejectedSubmissions() {
        try {
          logActivity('info', `Clearing all rejected submissions`);
          
          // Try Supabase directly
          const supabase = this.initSupabase();
          if (!supabase) {
            throw new Error("Supabase client not available");
          }
          
          // Count how many rejected submissions there are
          const { count, error: countError } = await supabase
            .from('submissions')
            .select('*', { count: 'exact', head: true })
            .eq('status', 'rejected');
            
          if (countError) throw countError;
          
          if (count === 0) {
            return {
              success: true,
              message: "No rejected submissions to clear"
            };
          }
          
          // Delete rejected submissions
          const { error: deleteError } = await supabase
            .from('submissions')
            .delete()
            .eq('status', 'rejected');
            
          if (deleteError) throw deleteError;
          
          // Update localStorage
          this.clearRejectedSubmissionsInLocalStorage();
          
          logActivity('success', `Successfully cleared ${count} rejected submissions from Supabase`);
          
          return {
            success: true,
            message: `Successfully cleared ${count} rejected submissions`
          };
        } catch (error) {
          logActivity('error', `Error clearing rejected submissions in Supabase: ${error.message}`);
          
          // Fall back to localStorage as a last resort
          this.clearRejectedSubmissionsInLocalStorage();
          
          logActivity('info', `Cleared rejected submissions in localStorage only`);
          
          return {
            success: true,
            message: "Rejected submissions cleared in localStorage only",
            offline: true
          };
        }
      },
      
      // Clear rejected submissions in localStorage
      clearRejectedSubmissionsInLocalStorage() {
        try {
          const submissions = JSON.parse(localStorage.getItem('appfoundry_submissions') || '[]');
          const updatedSubmissions = submissions.filter(sub => sub.status !== 'rejected');
          
          localStorage.setItem('appfoundry_submissions', JSON.stringify(updatedSubmissions));
          
          // Update seed immediately too
          localStorage.setItem('appfoundry_approved_seed', JSON.stringify(
            updatedSubmissions.filter(s => s.status === 'approved')
          ));
          
          logActivity('info', `Cleared rejected submissions in localStorage`);
          return true;
        } catch (error) {
          logActivity('error', `Error clearing rejected submissions in localStorage: ${error.message}`);
          return false;
        }
      },
      
      // Update submission (for editing)
      async updateSubmission(submission) {
        try {
          logActivity('info', `Updating submission ${submission.id}`);
          
          // Try direct Supabase update
          const supabase = this.initSupabase();
          if (!supabase) {
            throw new Error("Supabase client not available");
          }
          
          // Format the submission for Supabase
          const supabaseSubmission = {
            name: submission.name,
            email: submission.email,
            app_name: submission.appName,
            app_type: submission.appType,
            experience_level: submission.experienceLevel,
            testimonial: submission.testimonial,
            story: submission.story,
            updated_at: new Date().toISOString()
          };
          
          // Add images if provided
          if (submission.images) {
            supabaseSubmission.cloudinary_images = JSON.stringify(submission.images);
          }
          
          // Update in Supabase
          const { data, error } = await supabase
            .from('submissions')
            .update(supabaseSubmission)
            .eq('id', submission.id)
            .select()
            .single();
            
          if (error) throw error;
          
          // Update in localStorage
          this.updateSubmissionInLocalStorage(submission);
          
          // Format the result
          const formattedSubmission = {
            id: data.id,
            name: data.name,
            email: data.email,
            appName: data.app_name,
            appType: data.app_type,
            experienceLevel: data.experience_level,
            testimonial: data.testimonial,
            story: data.story,
            status: data.status,
            date: data.created_at,
            images: this.parseCloudinaryImages(data.cloudinary_images),
            featured: data.featured || false
          };
          
          logActivity('success', `Successfully updated submission ${submission.id} in Supabase`);
          
          return {
            success: true,
            message: "Submission updated successfully",
            submission: formattedSubmission
          };
        } catch (error) {
          logActivity('error', `Error updating submission in Supabase: ${error.message}`);
          
          // Fall back to localStorage as a last resort
          const success = this.updateSubmissionInLocalStorage(submission);
          
          if (success) {
            logActivity('info', `Updated submission ${submission.id} in localStorage only`);
            
            return {
              success: true,
              message: "Submission updated in localStorage only",
              offline: true
            };
          }
          
          throw error;
        }
      },
      
      // Update submission in localStorage
      updateSubmissionInLocalStorage(updatedSubmission) {
        try {
          // Find the submission
          const submissions = JSON.parse(localStorage.getItem('appfoundry_submissions') || '[]');
          const submissionIndex = submissions.findIndex(s => s.id === updatedSubmission.id);
          
          if (submissionIndex !== -1) {
            // Update the submission with new data
            submissions[submissionIndex] = {
              ...submissions[submissionIndex],
              ...updatedSubmission
            };
            
            // Save to localStorage
            localStorage.setItem('appfoundry_submissions', JSON.stringify(submissions));
            
            // Update seed immediately too
            localStorage.setItem('appfoundry_approved_seed', JSON.stringify(
              submissions.filter(s => s.status === 'approved')
            ));
            
            logActivity('info', `LocalStorage updated for submission ${updatedSubmission.id}`);
            return true;
          }
          
          logActivity('warning', `Could not find submission ${updatedSubmission.id} in localStorage for update`);
          return false;
        } catch (error) {
          logActivity('error', `Error updating submission in localStorage: ${error.message}`);
          return false;
        }
      },
      
      // Delete a submission
      async deleteSubmission(id) {
        try {
          logActivity('info', `Deleting submission ${id}`);
          
          // Try direct Supabase deletion
          const supabase = this.initSupabase();
          if (!supabase) {
            throw new Error("Supabase client not available");
          }
          
          // Delete from Supabase
          const { error } = await supabase
            .from('submissions')
            .delete()
            .eq('id', id);
            
          if (error) throw error;
          
          // Delete from localStorage
          this.deleteSubmissionFromLocalStorage(id);
          
          logActivity('success', `Successfully deleted submission ${id} from Supabase`);
          
          return {
            success: true,
            message: "Submission deleted successfully"
          };
        } catch (error) {
          logActivity('error', `Error deleting submission from Supabase: ${error.message}`);
          
          // Fall back to localStorage as a last resort
          const success = this.deleteSubmissionFromLocalStorage(id);
          
          if (success) {
            logActivity('info', `Deleted submission ${id} from localStorage only`);
            
            return {
              success: true,
              message: "Submission deleted from localStorage only",
              offline: true
            };
          }
          
          throw error;
        }
      },
      
      // Delete submission from localStorage
      deleteSubmissionFromLocalStorage(id) {
        try {
          const submissions = JSON.parse(localStorage.getItem('appfoundry_submissions') || '[]');
          const updatedSubmissions = submissions.filter(sub => sub.id !== id);
          
          if (submissions.length === updatedSubmissions.length) {
            logActivity('warning', `Submission ${id} not found in localStorage`);
            return false;
          }
          
          localStorage.setItem('appfoundry_submissions', JSON.stringify(updatedSubmissions));
          
          // Update seed immediately too
          localStorage.setItem('appfoundry_approved_seed', JSON.stringify(
            updatedSubmissions.filter(s => s.status === 'approved')
          ));
          
          logActivity('info', `Deleted submission ${id} from localStorage`);
          return true;
        } catch (error) {
          logActivity('error', `Error deleting submission from localStorage: ${error.message}`);
          return false;
        }
      },
      
      // Helper function to update localStorage as a fallback
      updateLocalStorage(id, status) {
        try {
          // Find the submission
          const submissions = JSON.parse(localStorage.getItem('appfoundry_submissions') || '[]');
          const submissionIndex = submissions.findIndex(s => s.id === id);
          
          if (submissionIndex !== -1) {
            // Update status
            submissions[submissionIndex].status = status;
            
            // Save to localStorage
            localStorage.setItem('appfoundry_submissions', JSON.stringify(submissions));
            
            // Update seed immediately too
            localStorage.setItem('appfoundry_approved_seed', JSON.stringify(
              submissions.filter(s => s.status === 'approved')
            ));
            console.log(`💾 LocalStorage updated: status of ${id} changed to ${status}`);
            logActivity('info', `LocalStorage updated: status of ${id} changed to ${status}`);
            return true;
          }
          
          logActivity('warning', `Could not find submission ${id} in localStorage`);
          return false;
        } catch (error) {
          console.error('❌ Error updating localStorage:', error);
          logActivity('error', `Error updating localStorage: ${error.message}`);
          return false;
        }
      },
      
      // Force sync submissions from Supabase to localStorage
      async forceSync() {
        try {
          logActivity('info', 'Force syncing submissions from Supabase');
          
          // Initialize Supabase client if needed
          const supabase = this.initSupabase();
          if (!supabase) {
            throw new Error("Supabase client not available");
          }
          
          // Get all submissions from Supabase
          const { data, error } = await supabase
            .from('submissions')
            .select('*')
            .order('created_at', { ascending: false });
            
          if (error) throw error;
          
          if (!Array.isArray(data) || data.length === 0) {
            logActivity('warning', 'No submissions found in Supabase');
            return { success: false, message: 'No submissions found in Supabase' };
          }
          
          // Format submissions
          const formattedSubmissions = data.map(submission => ({
            id: submission.id,
            name: submission.name,
            email: submission.email,
            appName: submission.app_name,
            appType: submission.app_type,
            experienceLevel: submission.experience_level,
            testimonial: submission.testimonial,
            story: submission.story,
            status: submission.status,
            date: submission.created_at,
            images: this.parseCloudinaryImages(submission.cloudinary_images),
            featured: submission.featured || false
          }));
          
          // Update localStorage
          localStorage.setItem('appfoundry_submissions', JSON.stringify(formattedSubmissions));
          
          // Update approved seed
          localStorage.setItem('appfoundry_approved_seed', JSON.stringify(
            formattedSubmissions.filter(s => s.status === 'approved')
          ));
          
          // Update last sync timestamp
          localStorage.setItem('appfoundry_last_sync', new Date().toISOString());
          
          // Look for featured story
          const featuredStory = formattedSubmissions.find(story => story.featured);
          if (featuredStory) {
            localStorage.setItem('appfoundry_featured_story', featuredStory.id);
          }
          
          logActivity('success', `Successfully synced ${formattedSubmissions.length} submissions from Supabase`);
          
          return {
            success: true,
            message: `Successfully synced ${formattedSubmissions.length} submissions from Supabase`,
            submissions: formattedSubmissions
          };
        } catch (error) {
          logActivity('error', `Force sync failed: ${error.message}`);
          throw error;
        }
      },
      
      // Track API failures for monitoring
      recordApiFailure(endpoint, method, error) {
        try {
          const failures = JSON.parse(localStorage.getItem('appfoundry_api_failures') || '[]');
          failures.push({
            endpoint,
            method,
            error: error.message,
            timestamp: new Date().toISOString()
          });
          
          // Keep only the last 50 failures
          if (failures.length > 50) {
            failures.shift();
          }
          
          localStorage.setItem('appfoundry_api_failures', JSON.stringify(failures));
        } catch (e) {
          console.error('Failed to record API failure:', e);
        }
      },
      
      // Get API failures history
      getApiFailures() {
        try {
          return JSON.parse(localStorage.getItem('appfoundry_api_failures') || '[]');
        } catch (e) {
          console.error('Failed to get API failures:', e);
          return [];
        }
      },
      
      // Run a health check for the system
      async checkSystemHealth() {
        try {
          logActivity('info', 'Running system health check');
          
          const results = {
            success: false,
            supabase: false,
            netlifyFunctions: false,
            details: []
          };
          
          // Check Supabase connection
          try {
            const supabase = this.initSupabase();
            if (!supabase) {
              throw new Error("Supabase client not available");
            }
            
            // Test a simple query
            const { data, error } = await supabase
              .from('submissions')
              .select('id')
              .limit(1);
              
            if (error) throw error;
            
            results.supabase = true;
            results.details.push({ component: 'Supabase', status: 'Connected' });
          } catch (supabaseError) {
            results.details.push({ component: 'Supabase', status: 'Error', message: supabaseError.message });
          }
          
          // Check Netlify Functions (optional)
          try {
            // Simple health check endpoint - you may need to implement this
            await fetch('/.netlify/functions/health-check');
            
            results.netlifyFunctions = true;
            results.details.push({ component: 'Netlify Functions', status: 'Connected' });
          } catch (netlifyError) {
            results.details.push({ component: 'Netlify Functions', status: 'Error', message: netlifyError.message });
          }
          
          // Overall status
          results.success = results.supabase || results.netlifyFunctions;
          
          return results;
        } catch (error) {
          logActivity('error', `System health check failed: ${error.message}`);
          
          return {
            success: false,
            message: error.message,
            details: [{ component: 'System', status: 'Error', message: error.message }]
          };
        }
      }
    };
    </script>
    
    <!-- Global Activity Log System -->
    <script>
      // Initialize activity log
      if (!localStorage.getItem('activity_log')) {
        localStorage.setItem('activity_log', JSON.stringify([]));
      }
      
      // Log activity with level (info, success, warning, error)
      function logActivity(level, message) {
        try {
          const activityLog = JSON.parse(localStorage.getItem('activity_log') || '[]');
          
          // Add new log entry
          activityLog.unshift({
            timestamp: new Date().toISOString(),
            level,
            message
          });
          
          // Keep only the most recent 500 entries
          if (activityLog.length > 500) {
            activityLog.pop();
          }
          
          localStorage.setItem('activity_log', JSON.stringify(activityLog));
          
          // Update UI if activity log is visible
          updateActivityLogDisplay();
        } catch (error) {
          console.error('Failed to log activity:', error);
        }
      }
      
      // Format timestamp for display
      function formatTimestamp(timestamp) {
        const date = new Date(timestamp);
        return date.toLocaleTimeString() + ' ' + date.toLocaleDateString();
      }
      
      // Update activity log display if visible
      function updateActivityLogDisplay() {
        const activityLogContainer = document.getElementById('activity-log-container');
        if (activityLogContainer && !activityLogContainer.classList.contains('hidden')) {
          displayActivityLog();
        }
      }
      
      // Display activity log in the UI
      function displayActivityLog() {
        const activityLog = JSON.parse(localStorage.getItem('activity_log') || '[]');
        const container = document.getElementById('activity-log-container');
        
        if (!container) return;
        
        const contentDiv = document.getElementById('activity-log-content');
        contentDiv.innerHTML = '';
        
        if (activityLog.length === 0) {
          contentDiv.innerHTML = '<p class="text-gray-500 italic">No activity logged yet.</p>';
          return;
        }
        
        activityLog.forEach(entry => {
          const entryDiv = document.createElement('div');
          entryDiv.className = 'py-2 border-b border-gray-200';
          
          let badgeClass = 'px-2 py-1 rounded text-xs font-semibold mr-2';
          
          switch (entry.level) {
            case 'success':
              badgeClass += ' bg-green-100 text-green-800';
              break;
            case 'warning':
              badgeClass += ' bg-yellow-100 text-yellow-800';
              break;
            case 'error':
              badgeClass += ' bg-red-100 text-red-800';
              break;
            default: // info
              badgeClass += ' bg-blue-100 text-blue-800';
          }
          
          entryDiv.innerHTML = `
            <div class="flex justify-between">
              <span class="${badgeClass}">${entry.level.toUpperCase()}</span>
              <span class="text-xs text-gray-500">${formatTimestamp(entry.timestamp)}</span>
            </div>
            <p class="text-sm mt-1">${entry.message}</p>
          `;
          
          contentDiv.appendChild(entryDiv);
        });
      }
      
      // Toggle activity log visibility
      function toggleActivityLog() {
        const container = document.getElementById('activity-log-container');
        
        if (container.classList.contains('hidden')) {
          container.classList.remove('hidden');
          displayActivityLog();
        } else {
          container.classList.add('hidden');
        }
      }
      
      // Clear activity log
      function clearActivityLog() {
        if (confirm('Are you sure you want to clear the activity log?')) {
          localStorage.setItem('activity_log', JSON.stringify([]));
          displayActivityLog();
          logActivity('info', 'Activity log cleared');
        }
      }
    </script>

    <!-- Backup and Restore System -->
    <script>
      // Export submissions as JSON file
      function exportSubmissions() {
        try {
          const submissions = JSON.parse(localStorage.getItem('appfoundry_submissions') || '[]');
          
          if (submissions.length === 0) {
            alert('No submissions to export');
            return;
          }
          
          // Create JSON file content
          const jsonContent = JSON.stringify(submissions, null, 2);
          const blob = new Blob([jsonContent], { type: 'application/json' });
          const url = URL.createObjectURL(blob);
          
          // Create download link
          const downloadLink = document.createElement('a');
          downloadLink.href = url;
          downloadLink.download = `appfoundry_submissions_backup_${new Date().toISOString().slice(0,10)}.json`;
          
          // Trigger download
          document.body.appendChild(downloadLink);
          downloadLink.click();
          document.body.removeChild(downloadLink);
          
          logActivity('success', `Exported ${submissions.length} submissions to JSON file`);
        } catch (error) {
          logActivity('error', `Failed to export submissions: ${error.message}`);
          alert(`Export failed: ${error.message}`);
        }
      }
      
      // Import submissions from JSON file
      function importSubmissions() {
        const fileInput = document.createElement('input');
        fileInput.type = 'file';
        fileInput.accept = '.json';
        
        fileInput.onchange = (event) => {
          const file = event.target.files[0];
          
          if (file) {
            const reader = new FileReader();
            
            reader.onload = function(e) {
              try {
                const submissions = JSON.parse(e.target.result);
                
                if (!Array.isArray(submissions)) {
                  throw new Error('Invalid file format. Expected an array of submissions.');
                }
                
                // Validate basic structure
                if (submissions.length > 0 && (!submissions[0].id || !submissions[0].date)) {
                  throw new Error('Invalid submission format. Missing required fields.');
                }
                
                // Confirm before overwriting
                if (confirm(`Are you sure you want to import ${submissions.length} submissions? This will overwrite existing data.`)) {
                  localStorage.setItem('appfoundry_submissions', JSON.stringify(submissions));
                  localStorage.setItem('appfoundry_approved_seed', JSON.stringify(
                    submissions.filter(s => s.status === 'approved')
                  ));
                  
                  logActivity('success', `Imported ${submissions.length} submissions from file`);
                  alert('Import successful! Please refresh the page to see the imported submissions.');
                }
              } catch (error) {
                logActivity('error', `Import failed: ${error.message}`);
                alert(`Import failed: ${error.message}`);
              }
            };
            
            reader.onerror = function() {
              logActivity('error', 'Failed to read file');
              alert('Failed to read file');
            };
            
            reader.readAsText(file);
          }
        };
        
        fileInput.click();
      }
    </script>
    
    <!-- Submission Editing System -->
    <script>
      // Current submission being edited
      let currentEditingSubmission = null;
      
      // Open edit modal with submission data
      function openEditModal(submission) {
        currentEditingSubmission = submission;
        
        // Set form values
        document.getElementById('edit-id').value = submission.id;
        document.getElementById('edit-name').value = submission.name || '';
        document.getElementById('edit-email').value = submission.email || '';
        document.getElementById('edit-app-name').value = submission.appName || '';
        document.getElementById('edit-app-type').value = submission.appType || submission.app_type || '';
        document.getElementById('edit-experience-level').value = submission.experienceLevel || '';
        document.getElementById('edit-testimonial').value = submission.testimonial || '';
        document.getElementById('edit-story').value = submission.story || '';
        
        // Setup image previews
        const imagePreviewContainer = document.getElementById('edit-image-previews');
        imagePreviewContainer.innerHTML = '';
        
        if (submission.images && submission.images.length > 0) {
          submission.images.forEach((imageUrl, index) => {
            if (imageUrl) {
              const imagePreview = document.createElement('div');
              imagePreview.className = 'relative';
              imagePreview.innerHTML = `
                <img src="${imageUrl}" alt="Preview ${index}" class="w-20 h-20 object-cover border rounded mr-2">
                <button type="button" class="absolute top-0 right-0 bg-red-500 text-white rounded-full w-5 h-5 flex items-center justify-center" onclick="removeImage(${index})">
                  <i class="fas fa-times text-xs"></i>
                </button>
              `;
              imagePreviewContainer.appendChild(imagePreview);
            }
          });
        }
        
        // Show the modal
        document.getElementById('edit-modal').classList.remove('hidden');
      }
      
      // Close edit modal
      function closeEditModal() {
        document.getElementById('edit-modal').classList.add('hidden');
        currentEditingSubmission = null;
      }
      
      // Remove image from current editing submission
      function removeImage(index) {
        if (currentEditingSubmission && currentEditingSubmission.images) {
          // Set to null instead of removing to maintain array indices
          currentEditingSubmission.images[index] = null;
          
          // Refresh image previews
          const imagePreviewContainer = document.getElementById('edit-image-previews');
          imagePreviewContainer.innerHTML = '';
          
          currentEditingSubmission.images.forEach((imageUrl, idx) => {
            if (imageUrl) {
              const imagePreview = document.createElement('div');
              imagePreview.className = 'relative';
              imagePreview.innerHTML = `
                <img src="${imageUrl}" alt="Preview ${idx}" class="w-20 h-20 object-cover border rounded mr-2">
                <button type="button" class="absolute top-0 right-0 bg-red-500 text-white rounded-full w-5 h-5 flex items-center justify-center" onclick="removeImage(${idx})">
                  <i class="fas fa-times text-xs"></i>
                </button>
              `;
              imagePreviewContainer.appendChild(imagePreview);
            }
          });
        }
      }
      
      // Save changes to submission
      async function saveSubmissionChanges() {
        try {
          if (!currentEditingSubmission) {
            throw new Error('No submission being edited');
          }
          
          // Get form values
          const updatedSubmission = {
            ...currentEditingSubmission,
            name: document.getElementById('edit-name').value,
            email: document.getElementById('edit-email').value,
            appName: document.getElementById('edit-app-name').value,
            appType: document.getElementById('edit-app-type').value,
            experienceLevel: document.getElementById('edit-experience-level').value,
            testimonial: document.getElementById('edit-testimonial').value,
            story: document.getElementById('edit-story').value,
            // Filter out null images
            images: currentEditingSubmission.images ? 
              currentEditingSubmission.images.filter(img => img !== null) : []
          };
          
          // Update submission
          document.getElementById('edit-save-button').disabled = true;
          document.getElementById('edit-save-button').textContent = 'Saving...';
          
          // Call API to update the submission
          await AdminAuth.updateSubmission(updatedSubmission);
          
          logActivity('success', `Successfully updated submission: ${updatedSubmission.id}`);
          
          // Close modal and refresh submissions
          closeEditModal();
          loadSubmissions();
        } catch (error) {
          logActivity('error', `Failed to save submission changes: ${error.message}`);
          alert(`Failed to save changes: ${error.message}`);
        } finally {
          document.getElementById('edit-save-button').disabled = false;
          document.getElementById('edit-save-button').textContent = 'Save Changes';
        }
      }
    </script>
    
    <!-- System Health Monitoring Script -->
    <script>
      // Check system health and connectivity
      async function checkSystemHealth() {
        try {
          document.getElementById('health-check-button').disabled = true;
          document.getElementById('health-check-button').innerHTML = '<i class="fas fa-spinner fa-spin"></i> Checking...';
          
          logActivity('info', 'Running system health check');
          
          // Test system health
          const healthResult = await AdminAuth.checkSystemHealth();
          
          if (healthResult.success) {
            const healthDetails = document.getElementById('health-details');
            
            // Create details HTML
            let detailsHtml = `
              <div class="bg-green-100 text-green-800 p-4 rounded">
                <h3 class="font-bold">✅ System Healthy</h3>
                <ul class="mt-2 space-y-1">
            `;
            
            // Add components details
            healthResult.details.forEach(component => {
              detailsHtml += `<li>${component.component}: ${component.status}</li>`;
            });
            
            detailsHtml += `
                </ul>
              </div>
            `;
            
            healthDetails.innerHTML = detailsHtml;
            
            logActivity('success', 'System health check passed');
          } else {
            const healthDetails = document.getElementById('health-details');
            
            // Create error details HTML
            let detailsHtml = `
              <div class="bg-red-100 text-red-800 p-4 rounded">
                <h3 class="font-bold">❌ System Issues Detected</h3>
                <p>${healthResult.message || 'Unknown error'}</p>
                <ul class="mt-2 space-y-1">
            `;
            
            // Add error details
            healthResult.details.forEach(component => {
              detailsHtml += `<li>${component.component}: ${component.status}${component.message ? ` - ${component.message}` : ''}</li>`;
            });
            
            detailsHtml += `
                </ul>
                <p class="mt-2">Try running a force sync or check your Supabase configuration.</p>
              </div>
            `;
            
            healthDetails.innerHTML = detailsHtml;
            
            logActivity('error', `System health check failed: ${healthResult.message}`);
          }
        } catch (error) {
          const healthDetails = document.getElementById('health-details');
          
          healthDetails.innerHTML = `
            <div class="bg-red-100 text-red-800 p-4 rounded">
              <h3 class="font-bold">❌ System Check Failed</h3>
              <p>${error.message}</p>
              <p class="mt-2">Unable to connect to API or Supabase. Check your network connection and configuration.</p>
            </div>
          `;
          
          logActivity('error', `System health check error: ${error.message}`);
        } finally {
          document.getElementById('health-check-button').disabled = false;
          document.getElementById('health-check-button').innerHTML = '<i class="fas fa-heartbeat"></i> Check System Health';
        }
      }
      
      // Force sync submissions from Supabase
      async function forceSyncSubmissions() {
        if (!confirm('Are you sure you want to force sync all submissions from Supabase? This will overwrite local data.')) {
          return;
        }
        
        try {
          // Show loading indicator
          document.getElementById('force-sync-button').disabled = true;
          document.getElementById('force-sync-button').innerHTML = '<i class="fas fa-spinner fa-spin"></i> Syncing...';
          document.getElementById('loading-indicator').style.display = 'flex';
          document.getElementById('submissions').style.display = 'none';
          
          logActivity('info', 'Force syncing submissions from Supabase...');
          
          const syncResult = await AdminAuth.forceSync();
          
          if (syncResult.success) {
            logActivity('success', `Successfully synced ${syncResult.submissions?.length || 0} submissions from Supabase`);
            alert(`Sync successful! ${syncResult.submissions?.length || 0} submissions synced.`);
            loadSubmissions(); // Refresh the display
          } else {
            logActivity('error', `Sync failed: ${syncResult.message}`);
            alert(`Sync failed: ${syncResult.message}`);
          }
        } catch (error) {
          logActivity('error', `Force sync error: ${error.message}`);
          alert(`Sync failed: ${error.message}`);
        } finally {
          document.getElementById('force-sync-button').disabled = false;
          document.getElementById('force-sync-button').innerHTML = '<i class="fas fa-sync-alt"></i> Force Sync from Supabase';
          document.getElementById('loading-indicator').style.display = 'none';
        }
      }
    </script>
    
    <!-- Main App Script -->
    <script>
      // Global variables
      let allSubmissions = [];
      let currentTab = 'all';
      let currentPage = 1;
      let itemsPerPage = 6;
      let sortNewestFirst = true;
      
      // Load submissions when page loads
      document.addEventListener('DOMContentLoaded', function() {
        logActivity('info', 'Admin dashboard loaded');
        
        // Initialize Supabase if available
        AdminAuth.initSupabase();
        
        // Set up sort switch
        document.getElementById('sort-switch').addEventListener('change', function() {
          sortNewestFirst = this.checked;
          displaySubmissions();
        });
        
        // Load submissions
        loadSubmissions();
      });
      
      // Load submissions using the AdminAuth helper
      async function loadSubmissions() {
        try {
          // Show loading indicator
          document.getElementById('loading-indicator').style.display = 'flex';
          document.getElementById('submissions').style.display = 'none';
          document.getElementById('empty-state').style.display = 'none';
          
          logActivity('info', `Fetching ${currentTab} submissions...`);
          
          // Use the AdminAuth helper
          const submissions = await AdminAuth.getSubmissions(currentTab);
          allSubmissions = submissions;
          
          logActivity('info', `Loaded ${allSubmissions.length} submissions`);
          
          // If we still have no submissions, fall back to localStorage
          if (allSubmissions.length === 0) {
            fallbackToLocalStorage();
          } else {
            displaySubmissions();
          }
        } catch (error) {
          logActivity('error', `Error loading submissions: ${error.message}`);
          fallbackToLocalStorage();
        } finally {
          document.getElementById('loading-indicator').style.display = 'none';
        }
      }
      
      // Fallback to localStorage if API fails
      function fallbackToLocalStorage() {
        logActivity('warning', "API call failed, falling back to localStorage");
        
        try {
          const storedSubmissions = localStorage.getItem('appfoundry_submissions');
          
          if (storedSubmissions) {
            allSubmissions = JSON.parse(storedSubmissions);
            
            // Filter by status if needed
            if (currentTab !== 'all') {
              allSubmissions = allSubmissions.filter(sub => sub.status === currentTab);
            }
            
            logActivity('info', `Loaded ${allSubmissions.length} submissions from localStorage (fallback)`);
            displaySubmissions();
          } else {
            logActivity('warning', "No submissions found in localStorage");
            showEmptyState();
          }
        } catch (localStorageError) {
          logActivity('error', `Error loading from localStorage: ${localStorageError.message}`);
          showEmptyState();
        }
      }
      
      // Display submissions based on current filter
      function displaySubmissions() {
        // Filter submissions based on current tab
        let filteredSubmissions = allSubmissions;
        
        if (currentTab !== 'all' && filteredSubmissions.some(sub => sub.status)) {
          filteredSubmissions = allSubmissions.filter(submission => submission.status === currentTab);
          logActivity('info', `Filtered to ${filteredSubmissions.length} '${currentTab}' submissions`);
        }
        
        // Sort submissions
        filteredSubmissions.sort((a, b) => {
          const dateA = new Date(a.date);
          const dateB = new Date(b.date);
          return sortNewestFirst ? dateB - dateA : dateA - dateB;
        });
        
        // Show empty state if no submissions
        if (filteredSubmissions.length === 0) {
          showEmptyState();
          return;
        }
        
        // Calculate pagination
        const totalPages = Math.ceil(filteredSubmissions.length / itemsPerPage);
        if (currentPage > totalPages) {
          currentPage = 1;
        }
        
        // Get current page items
        const startIndex = (currentPage - 1) * itemsPerPage;
        const endIndex = Math.min(startIndex + itemsPerPage, filteredSubmissions.length);
        const currentItems = filteredSubmissions.slice(startIndex, endIndex);
        
        logActivity('info', `Displaying page ${currentPage} (${startIndex+1}-${endIndex} of ${filteredSubmissions.length})`);
        
        // Display current items
        const submissionsContainer = document.getElementById('submissions');
        submissionsContainer.innerHTML = '';
        
        currentItems.forEach(submission => {
          const submissionCard = createSubmissionCard(submission);
          submissionsContainer.appendChild(submissionCard);
        });
        
        // Update pagination
        updatePagination(totalPages);
        
        // Hide empty state and show submissions
        document.getElementById('empty-state').style.display = 'none';
        document.getElementById('submissions').style.display = 'grid';
      }
      
      // Create a submission card
      function createSubmissionCard(submission) {
        const card = document.createElement('div');
        card.className = 'bg-white rounded-lg shadow overflow-hidden border border-gray-200';
        card.setAttribute('data-id', submission.id);
        
        // Get status label and class
        let statusLabel = 'Pending';
        let statusClass = 'bg-yellow-100 text-yellow-800';
        
        if (submission.status === 'approved') {
          statusLabel = 'Approved';
          statusClass = 'bg-green-100 text-green-800';
        } else if (submission.status === 'rejected') {
          statusLabel = 'Rejected';
          statusClass = 'bg-red-100 text-red-800';
        }
        
        // Format date
        const date = new Date(submission.date);
        const formattedDate = date.toLocaleDateString('en-US', {
          year: 'numeric',
          month: 'short',
          day: 'numeric'
        });
        
        // Create card HTML
        card.innerHTML = `
          <div class="flex justify-between items-center bg-gray-50 px-4 py-3 border-b border-gray-200">
            <div class="font-semibold text-gray-800">${submission.appName}</div>
            <div class="px-2 py-1 rounded text-xs ${statusClass}">${statusLabel}</div>
          </div>
          <div class="p-4">
            <div class="grid grid-cols-2 gap-4 mb-4">
              <div>
                <div class="text-xs text-gray-500">Submitted By</div>
                <div class="text-sm">${submission.name || 'Unknown'}</div>
              </div>
              <div>
                <div class="text-xs text-gray-500">Email</div>
                <div class="text-sm truncate">${submission.email || 'N/A'}</div>
              </div>
              <div>
                <div class="text-xs text-gray-500">App Type</div>
                <div class="text-sm">${submission.appType || submission.app_type || 'Not specified'}</div>
              </div>
              <div>
                <div class="text-xs text-gray-500">Experience Level</div>
                <div class="text-sm">${submission.experienceLevel || 'Not specified'}</div>
              </div>
            </div>
            
            <div class="mb-4">
              <div class="text-xs text-gray-500">Testimonial</div>
              <div class="text-sm italic bg-gray-50 p-2 rounded mt-1">${submission.testimonial || 'No testimonial provided'}</div>
            </div>
            
            <div>
              <div class="text-xs text-gray-500">Submitted On</div>
              <div class="text-sm">${formattedDate}</div>
            </div>
          </div>
        `;
        
        // Add images if available
        if (submission.images && submission.images.length > 0) {
          const cardBody = card.querySelector('.p-4');
          const imagesDiv = document.createElement('div');
          imagesDiv.className = 'mt-4';
          imagesDiv.innerHTML = '<div class="text-xs text-gray-500 mb-2">Images</div>';
          
          const imagesGrid = document.createElement('div');
          imagesGrid.className = 'flex flex-wrap gap-2';
          
          submission.images.forEach((imageUrl, index) => {
            if (imageUrl) {
              const img = document.createElement('img');
              img.src = imageUrl;
              img.alt = `${submission.appName} Screenshot ${index + 1}`;
              img.className = 'w-16 h-16 object-cover rounded border border-gray-200 cursor-pointer';
              img.onclick = function() {
                showImage(imageUrl);
              };
              imagesGrid.appendChild(img);
            }
          });
          
          imagesDiv.appendChild(imagesGrid);
          cardBody.appendChild(imagesDiv);
        }
        
        // Add action buttons
        const actionsDiv = document.createElement('div');
        actionsDiv.className = 'flex items-center justify-end gap-2 p-4 bg-gray-50 border-t border-gray-200';
        
        // View Full Story button
        const viewButton = document.createElement('button');
        viewButton.className = 'px-3 py-1 bg-gray-200 text-gray-700 rounded hover:bg-gray-300 transition-colors text-sm';
        viewButton.innerHTML = '<i class="fas fa-eye mr-1"></i> View';
        viewButton.onclick = function() {
          showStory(submission);
        };
        actionsDiv.appendChild(viewButton);
        
        // Edit button
        const editButton = document.createElement('button');
        editButton.className = 'px-3 py-1 bg-blue-500 text-white rounded hover:bg-blue-600 transition-colors text-sm';
        editButton.innerHTML = '<i class="fas fa-edit mr-1"></i> Edit';
        editButton.onclick = function() {
          openEditModal(submission);
        };
        actionsDiv.appendChild(editButton);
        
        // Add approve/reject buttons based on current status
        if (submission.status === 'pending') {
          // Approve button
          const approveButton = document.createElement('button');
          approveButton.className = 'px-3 py-1 bg-green-500 text-white rounded hover:bg-green-600 transition-colors text-sm';
          approveButton.innerHTML = '<i class="fas fa-check mr-1"></i> Approve';
          approveButton.onclick = function() {
            approveSubmission(submission.id);
          };
          actionsDiv.appendChild(approveButton);
          
          // Reject button
          const rejectButton = document.createElement('button');
          rejectButton.className = 'px-3 py-1 bg-red-500 text-white rounded hover:bg-red-600 transition-colors text-sm';
          rejectButton.innerHTML = '<i class="fas fa-times mr-1"></i> Reject';
          rejectButton.onclick = function() {
            rejectSubmission(submission.id);
          };
          actionsDiv.appendChild(rejectButton);
        } else if (submission.status === 'approved') {
          // Featured status indicator and button
          const featuredButton = document.createElement('button');
          
          if (submission.featured) {
            // If already featured, show indicator
            featuredButton.className = 'px-3 py-1 bg-yellow-500 text-white rounded hover:bg-yellow-600 transition-colors text-sm';
            featuredButton.innerHTML = '<i class="fas fa-star mr-1"></i> Featured';
            featuredButton.disabled = true;
          } else {
            // If not featured, show "Set as Featured" button
            featuredButton.className = 'px-3 py-1 bg-yellow-100 text-yellow-700 rounded hover:bg-yellow-200 transition-colors text-sm';
            featuredButton.innerHTML = '<i class="fas fa-star mr-1"></i> Set as Featured';
            featuredButton.onclick = function() {
              setFeaturedStory(submission.id);
            };
          }
          
          // Add before the reject button
          actionsDiv.appendChild(featuredButton);
          
          // Reject button (can change from approved to rejected)
          const rejectButton = document.createElement('button');
          rejectButton.className = 'px-3 py-1 bg-red-500 text-white rounded hover:bg-red-600 transition-colors text-sm';
          rejectButton.innerHTML = '<i class="fas fa-times mr-1"></i> Reject';
          rejectButton.onclick = function() {
            rejectSubmission(submission.id);
          };
          actionsDiv.appendChild(rejectButton);
        } else if (submission.status === 'rejected') {
          // Approve button (can change from rejected to approved)
          const approveButton = document.createElement('button');
          approveButton.className = 'px-3 py-1 bg-green-500 text-white rounded hover:bg-green-600 transition-colors text-sm';
          approveButton.innerHTML = '<i class="fas fa-check mr-1"></i> Approve';
